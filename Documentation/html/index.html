<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fleet: Fleet - Fast inference in the Language of Thought</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_sm.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fleet
   &#160;<span id="projectnumber">0.0.9</span>
   </div>
   <div id="projectbrief">Inference in the LOT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Fleet - Fast inference in the Language of Thought </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>Fleet is a C++ library for programming language of thought models. In these models, we specify a grammar of primitive operations which can be composed to form complex hypotheses. These hypotheses are best thought of as programs in a (mental) programming language, and the job of learners is to observe data (typically inputs and outputs of programs) and infer the most likely program to have generated the outputs from the inputs. This is accomplished in Fleet by using a fully-Bayesian setup, with a prior over programs typically defined thought a Probabilistic Context-Free <a class="el" href="class_grammar.html">Grammar</a> (PCFG) and a likelihood model that typically says that the output of a program is observed with some noise.</p>
<p>Fleet is most similar to LOTlib (<a href="https://github.com/piantado/LOTlib3">https://github.com/piantado/LOTlib3</a>) but is considerably faster. LOTlib converts grammar productions into python expressions which are then evaled in python; this process is flexible and powerful, but slow. Fleet avoids this by implementing a lightweight stack-based virtual machine in which programs can be directly evaluated. This is especially advantageous when evaluating stochastic hypotheses (e.g. those using <a class="el" href="_random_8h.html#a40e7e030d95195c87c566b03fdefe44c">flip()</a> or <a class="el" href="_random_8h.html#a3585a6278806f57b964ccd1060f3b8ee">sample()</a>) in which multiple execution paths must be evaluated. Fleet stores these multiple execution traces of a single program in a priority queue (sorted by probability) and allows you to rapidly explore the space of execution traces.</p>
<p>Fleet is structured to automatically create this virtual machine and a grammar for programs from just the type specification on primitives: a function signature yields a PCFG because the return type can be thought of as a nonterminal in a PCFG and its arguments can be thought of as children (right hand side of a PCFG rule). A PCFG expanded in this way will yield a correctly-typed expression, a program, where each function has arguments of the correct types. Note that in Fleet, these types in the PCFG must be C++ types (intrinsics, classes, or structs), and two types that are the same are always considered to have the same nonterminal type.</p>
<p>Fleet requires you to define a <a class="el" href="class_grammar.html">Grammar</a> which includes <em>all</em> of the nonterminal types that are used anywhere in the grammar. Fleet makes heavy use of template metaprogramming, which prevents you from ever having to explicitly write the grammar itself, but it does implicitly construct a grammar using these operations.</p>
<p>In addition, Fleet has a number of built-in operations, which do special things to the virtual machine. These include <a class="el" href="namespace_builtins.html#afc5e30bbc3268c0f88d8540421d453ff">Builtins::Flip</a>, which stores multiple execution traces; <a class="el" href="namespace_builtins.html#abadd5f4188def3a49ec73f692460c9a2">Builtins::If</a> which uses short-circuit evaluation; <a class="el" href="namespace_builtins.html#a0771c881975000f812bbb41fffcb9fb0">Builtins::Recurse</a>, which handles recursives hypotheses; and <a class="el" href="namespace_builtins.html#a25cc5743603132ee78d118a4ca039c68">Builtins::X</a> which provides the argument to the expression.</p>
<h2><a class="anchor" id="subsec_install"></a>
Installation</h2>
<p>Fleet is based on header-files, and requires no additional dependencies. Command line arguments are processed in CL11.hpp, which is included in src/dependencies/.</p>
<p>The easiest way to begin using Fleet is to modify one of the examples. For simple rational-rules style inference, try Models/RationalRules; for an example using stochastic operations, try Models/FormalLanguageTheory-Simple.</p>
<p>Fleet is developed using GNU g++ 10 and requires C++-20.</p>
<h2><a class="anchor" id="subsec_examples"></a>
Examples</h2>
<p>Fleet contains several implemented examples of existing program-induction models, including identical or close variants of:</p>
<ul>
<li>The rational rules model (Examples/RationalRules): Goodman, N. D., Tenenbaum, J. B., Feldman, J., &amp; Griffiths, T. L. (2008). A rational analysis of rule‚Äêbased concept learning. Cognitive science, 32(1), 108-154.</li>
<li>The number model (Examples/Number-Simple): Piantadosi, S. T., Tenenbaum, J. B., &amp; Goodman, N. D. (2012). Bootstrapping in a language of thought: A formal model of numerical concept learning. Cognition, 123(2), 199-217.</li>
<li>The number game (Examples/NumberGame): Tenenbaum, J. B. (1999). A Bayesian framework for concept learning (Doctoral dissertation, Massachusetts Institute of Technology).</li>
<li>Inference of a grammar (Examples/GrammarInference-*): Piantadosi, S. T., Tenenbaum, J. B., &amp; Goodman, N. D. (2016). The logical primitives of thought: Empirical foundations for compositional cognitive models. Psychological review, 123(4), 392.</li>
<li>Formal language theory learning (Examples/FormalLanguageTheory-*): Yang &amp; Piantadosi, forthcoming</li>
</ul>
<p>as well as several other examples, including sorting and first order logical theories.</p>
<h2><a class="anchor" id="subsec_style"></a>
Style</h2>
<p>Fleet is currently written using a signle-file, header-only style. This allows for rapid refactoring and prototyping since declarations and implementations are not in separate files. This style may change in the future because it also leads to slower compilation times.</p>
<h2><a class="anchor" id="subsec_inference"></a>
Inference</h2>
<p>Fleet provides a number of simple inference routines to use. Examples of each can be found in Models/Sorting</p>
<ul>
<li>Markov-Chain Monte-Carlo</li>
<li>MCMC With Parallel Tempering</li>
<li>Monte-Carlo Tree search</li>
<li>Beam search</li>
<li>Enumeration (with a fast, fancy implementation)</li>
</ul>
<p>Generally, we find that <a class="el" href="class_parallel_tempering.html">ParallelTempering</a> is the fastest and most effective way to search these spaces of programs. These can be compared in Models/Sorting, which has examples of each. <br  />
</p>
<h1><a class="anchor" id="tutorial_sec"></a>
Tutorial</h1>
<p>To illustrate how Fleet works, let's walk through a simple example: the key parts of FormalLanguageTheory-Simple. This is a program induction model which takes a collection of strings and tries to find a stochastic program which can explain the observed strings. For example, it might see data like {"ab", "abab", "ababab"} and then infer that the language is (ab)^n.</p>
<p>Let's first walk through the grammar definition. Here, we first import <a class="el" href="_grammar_8h.html" title="A grammar stores all of the rules associated with any kind of nonterminal and permits us to sample as...">Grammar.h</a> and also <a class="el" href="_singleton_8h.html">Singleton.h</a>. <a class="el" href="class_singleton.html">Singleton</a> is a design pattern that permits only one copy of an object to be constructed, which is used here to ensure that we only have one grammar (and aren't, e.g. passing copies of it around). Typical to Fleet's code, we define our own grammar as MyGrammar. The first two template arguments are the input and output types of the function we are learning (here, strings to strings) and the next two are (variadic) template arguments for all of the nonterminal types used by the grammar (here, strings and bools). The input type determines the type of any arguments to productions in the grammar; the output type determines the type of the root (e.g. what evaluating a program generated from this grammar will return).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="keyword">using</span> S = std::string; <span class="comment">// just for convenience</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_grammar_8h.html">Grammar.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_singleton_8h.html">Singleton.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyGrammar : <span class="keyword">public</span> <a class="code" href="class_grammar.html">Grammar</a>&lt;S,S,  S,bool&gt;,</div>
<div class="line">                  <span class="keyword">public</span> <a class="code" href="class_singleton.html">Singleton</a>&lt;MyGrammar&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyGrammar() {</div>
<div class="line">        <span class="comment">// compute the tail of a string: tail(wxyz) -&gt; xyz</span></div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;tail(%s)&quot;</span>,      +[](S s)      -&gt; S { <span class="keywordflow">return</span> (s.empty() ? S(<span class="stringliteral">&quot;&quot;</span>) : s.substr(1,S::npos)); });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// compute the head of a string: tail(wxyz) -&gt; w</span></div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;head(%s)&quot;</span>,      +[](S s)      -&gt; S { <span class="keywordflow">return</span> (s.empty() ? S(<span class="stringliteral">&quot;&quot;</span>) : S(1,s.at(0))); });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// concatenate strings pair(wx,yz) -&gt; wxyz</span></div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;pair(%s,%s)&quot;</span>,   +[](S a, S b) -&gt; S { </div>
<div class="line">            <span class="keywordflow">if</span>(a.length() + b.length() &gt; MAX_LENGTH) <span class="keywordflow">throw</span> <a class="code" href="class_v_m_s_runtime_error.html">VMSRuntimeError</a>(); <span class="comment">// caught inside VirtualMachineState::run</span></div>
<div class="line">            <span class="keywordflow">else</span>                                     <span class="keywordflow">return</span> a+b; </div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// the empty string</span></div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;\u00D8&quot;</span>,        +[]()         -&gt; S          { <span class="keywordflow">return</span> S(<span class="stringliteral">&quot;&quot;</span>); });</div>
<div class="line">          </div>
<div class="line">        <span class="comment">// check if two strings are equal</span></div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;(%s==%s)&quot;</span>,      +[](S x, S y) -&gt; <span class="keywordtype">bool</span>       { <span class="keywordflow">return</span> x==y; });</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">        <span class="comment">// logical operations</span></div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;and(%s,%s)&quot;</span>,    Builtins::And&lt;MyGrammar&gt;);</div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;or(%s,%s)&quot;</span>,     Builtins::Or&lt;MyGrammar&gt;);</div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;not(%s)&quot;</span>,       Builtins::Not&lt;MyGrammar&gt;);</div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;if(%s,%s,%s)&quot;</span>,  Builtins::If&lt;MyGrammar,S&gt;);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// access the argument x to the program (defined to a string type above)</span></div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;x&quot;</span>,             Builtins::X&lt;MyGrammar&gt;);</div>
<div class="line">         </div>
<div class="line">        <span class="comment">// random coin flip (this does something fancy in evaluation)</span></div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;flip()&quot;</span>,        Builtins::Flip&lt;MyGrammar&gt;, 10.0);</div>
<div class="line">         </div>
<div class="line">        <span class="comment">// recursion</span></div>
<div class="line">        <a class="code" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">add</a>(<span class="stringliteral">&quot;recurse(%s)&quot;</span>,   Builtins::Recurse&lt;MyGrammar&gt;);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// add all the characters in our alphabet (alphabet is global variable defined on the command line)</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> c : alphabet) {</div>
<div class="line">            <a class="code" href="class_grammar.html#af43a4d8c3c2c7df80a916a5219b7232c">add_terminal</a>( <a class="code" href="_strings_8h.html#a1bb5ec0bee0c8456e3fcc87cc012d055">Q</a>(S(1,c)), S(1,c), 5.0/alphabet.length());</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">    }</div>
<div class="line">} grammar;</div>
</div><!-- fragment --><p>Then, in the constructor MyGrammar(), we call the member function <a class="el" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">Grammar::add</a> which takes two arguments: a string for how to show the function (called a "format"), and a lambda expression for the function itself. The string formats are just for show &ndash; they have nothing to do with how the program is evaluated and expressions in these strings are never interpreted as code. Each string format uses "%s" to denote the string of its children. So, when Fleet is asked to display a program, it recursively substitutes into these format strings. Fleet checks for you that you have as many "%s"es as you have arguments to each function and will complain if it's wrong. (NOTE: if you need to display children in a different ordered sequence, Fleet also supports this via "%1", "%2", etc.).</p>
<p>The second argument to <a class="el" href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">Grammar::add</a> is a lambda expression which computes and returns the value of each function (e.g. for "tail(%s)" it compute the tail of a string &ndash; everything except the first character. Note that this function, as is generally the case in Fleet, attempts to be relatively fault-tolerant rather than throwing exceptions because that's faster. In this case, we just define the tail of an empty string to be the empty string, rather than an error.</p>
<p>The functions for computing the head of a string is defined similarly. The "pair(%s,%s)" function is meant to concatenate strings but it actually needs to do a little checking because otherwise it's very easy to write programs which create exponentially long strings. So this function checks if its two argument lengths are above a global variable MAX_LENGTH and if so it throws a <a class="el" href="class_v_m_s_runtime_error.html">VMSRuntimeError</a> (<a class="el" href="class_virtual_machine_state.html">VirtualMachineState</a> error) which is caught and handled internally in Fleet. (Note that in the actual Model code, there is a more complex version of pair which is a bit faster, as it modifies strings stored in the <a class="el" href="class_virtual_machine_state.html">VirtualMachineState</a> stack rather than passing them around, as here).</p>
<p>Then, we have a function which takes no arguments and only returns the empty string. Here, we have given it a Unicode name \u00D8 which will appear/render in most terminals as epsilon (a convention for the empty string in formal language theory).</p>
<p>The "(%s==%s)" function computes whether two strings are equal and returns a bool. Note that generally it is helpful to enclose expressions like this in parentheses (i.e. "(...)") because without this, the printed programs can be ambiguous.</p>
<p>Note that in each of these lambda expressions, the input types (e.g. "S a, S b" in "pair") and return type (S) really matter. Fleet uses some fancy template magic to extract these types from the functions themselves and build the required grammar. That allows it to start with MyGrammar's return type and sample a composition of functions which yield this type.</p>
<p>MyGrammar also adds built-in logical operations. <a class="el" href="namespace_builtins.html">Builtins</a> are functions that we do <em>not</em> define ourselves using lambdas. We certainly could, but these are buitlin because they are a bit fancier than what you might think. Specifically, in most computer science applications we want the versions of these functions which involve <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short circuit evaluation</a>. For example, and(x,y) won't evaluate y if x is false, which for us ends up with a measurably faster implementation. This is maybe most important though for "if(%s,%s,%s)", where we only want to evaluate one branch, depending on which way the boolean comes out. The implementation of correct short-circuit evaluation depends on some of the internals of Fleet and so it's best to use the built-in versions of these functions.</p>
<p>We also have a special fucntion <a class="el" href="namespace_builtins.html#a25cc5743603132ee78d118a4ca039c68">Builtins::X</a> which provides the argument to the function/program we are learning. We defaulty give this the name "x".</p>
<p>The "flip()" primitive is somewhat fancy (and Buillt-in) because it is a stochastic operation, which acts like a coin flip, returning true half of the time and false half of the time (Fleet also a built-in biased coin, which takes a coin weight as a parameter). This is fancy because it means that when the program evaluates, there is no longer one single output, but rather a distribution of possible return values. Fleet will hand these back to you as a <a class="el" href="class_discrete_distribution.html">DiscreteDistribution</a> of the output type of the function. Here, we have included 10.0 after the <a class="el" href="namespace_builtins.html#afc5e30bbc3268c0f88d8540421d453ff">Builtins::Flip</a>. This is an optional number which can be included for any primitive and it determines the probability in the PCFG of each each expansion (they are summed and renormalized for each nonterminal type). In this case, we need to upweight the probability of Flip in order to make a proper PCFG (e.g. one where no probabliity is given to infinite trees) because otherwise the and,or,not operatiosn above will lead to infinite trees. The default weight for all operations (when its not specified) is 1.0, meaning that 10.0 makes it ten times as likely that a bool will expand to a flip than the others. In general, you will want to upweight the terminal rules (those with no children) in order to keep grammars proper.</p>
<p>The next operation is <a class="el" href="namespace_builtins.html#a0771c881975000f812bbb41fffcb9fb0">Builtins::Recurse</a>, which allows a defined function to call itself recursively. This is a special <a class="el" href="struct_builtin.html">Builtin</a> because it requires us to evaluate the entire program in which it occurs again, and use the output of that program. Note that in general as we search over programs, we will find things that recurse infinitely &ndash; Fleet's <a class="el" href="class_virtual_machine_state.html">VirtualMachineState</a> keeps track of how many recursive calls a single program has made (via <a class="el" href="class_virtual_machine_state.html#aa35593f67d1ea4e838fec8e7a8d33897">VirtualMachineState::recursion_depth</a>) and when it exceeds <a class="el" href="struct_virtual_machine_control.html#a486795b8d9b8aab1d62840da25ae91be">VirtualMachineControl::MAX_RECURSE</a> or when the total runtime exceeds <a class="el" href="struct_virtual_machine_control.html#a963c0a16ad95a4723255b4ce6eafb113">VirtualMachineControl::MAX_RUN_PROGRAM</a>, Fleet will halt evaluation of the program.</p>
<p>Finally, this grammar adds one terminal rule for each character in the global string "alphabet." Here, these characters are converted to strings containing a single character because char is not a nonterminal type in the grammar we defined. The entire collection of characters is given an unnonormalized grammar probabiltiy of 5.0.</p>
<p>Next, we define a class, MyHypothesis, which defines the program hypotheses we are going to be learning. The simplest form for this is to use something of type <a class="el" href="class_l_o_t_hypothesis.html">LOTHypothesis</a>, which defines built-in functions for computing the prior, copying, proposing, etc. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_l_o_t_hypothesis_8h.html">LOTHypothesis.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Declare a hypothesis class</span></div>
<div class="line"><span class="keyword">class </span>MyHypothesis : <span class="keyword">public</span> <a class="code" href="class_l_o_t_hypothesis.html">LOTHypothesis</a>&lt;MyHypothesis,S,S,MyGrammar,&amp;grammar&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> Super =  <a class="code" href="class_l_o_t_hypothesis.html">LOTHypothesis&lt;MyHypothesis,S,S,MyGrammar&gt;</a>;</div>
<div class="line">    <span class="keyword">using</span> Super::Super; <span class="comment">// inherit the constructors</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">double</span> <a class="code" href="class_l_o_t_hypothesis.html#a020bfe8e12d80add92c665518650c4cb">compute_single_likelihood</a>(<span class="keyword">const</span> datum_t&amp; x)<span class="keyword"> override </span>{   </div>
<div class="line">     </div>
<div class="line">        <span class="comment">// MyHypothesis stores a program, and &quot;call&quot; will call it with a given input</span></div>
<div class="line">        <span class="comment">// The output is a DiscreteDistribution on all of the outputs of that program</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> out = <a class="code" href="class_l_o_t_hypothesis.html#a625f5094ee8f59e8ada3a7bf5a6dd68f">call</a>(x.input, <span class="stringliteral">&quot;&quot;</span>); </div>
<div class="line">          </div>
<div class="line">        <span class="comment">// we need this to compute the likelihood</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> log_A = log(alphabet.size());</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Likelihood comes from all of the ways that we can delete from the end and the append to make the observed output. </span></div>
<div class="line">        <span class="comment">// So this requires us to sum over all of the output values, for a single data point. </span></div>
<div class="line">        <span class="keywordtype">double</span> lp = -<a class="code" href="_numerics_8h.html#af9434aea82baf2f6a5d9b6f9e36db08e">infinity</a>;</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; o : out.values()) { <span class="comment">// add up the probability from all of the strings</span></div>
<div class="line">            lp = <a class="code" href="_numerics_8h.html#a558a1133b9942f8debd559bb9317bca3">logplusexp</a>(lp, o.second + p_delete_append&lt;strgamma,strgamma&gt;(o.first, x.output, log_A));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> lp;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="class_bayesable.html#a87d5d9481d6a72b017e44b175071fa5e">print</a>(std::string prefix=<span class="stringliteral">&quot;&quot;</span>)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Override the default &quot;print&quot; function by prepending on a view of the distribution </span></div>
<div class="line">        <span class="comment">// that was output (Fleet normally would just show the program)</span></div>
<div class="line">        prefix = prefix+<span class="stringliteral">&quot;#\n#&quot;</span> +  this-&gt;<a class="code" href="class_l_o_t_hypothesis.html#a625f5094ee8f59e8ada3a7bf5a6dd68f">call</a>(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;&lt;err&gt;&quot;</span>).string() + <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        <a class="code" href="namespace_fleet_args.html#acf2f80bb2810cea3b3eeef0c4b0edf03">Super::print</a>(prefix); </div>
<div class="line">    }</div>
<div class="line">};  </div>
</div><!-- fragment --><p>Here, MyHypothesis uses the <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">curiously recurring template pattern</a> to pass itself, so that it knows how to make copies of itself. The other template arguments are the input and output types of its function (string to string) and the <a class="el" href="class_grammar.html">Grammar</a> type it uses (MyGrammar). The address of the grammar itself &amp;grammar is also part of the type. Then, we inherit <a class="el" href="class_l_o_t_hypothesis.html">LOTHypothesis</a>' constructors (via Super::Super's <a href="https://en.wikipedia.org/wiki/C%2B%2B11#Object_construction_improvement">insanity</a> in C++).</p>
<p>Primarily, what we have to define here is the compute_single_likelihood function, which defines the likelihood of a single observed data string. To compute this, we first call the function (<a class="el" href="class_l_o_t_hypothesis.html#a625f5094ee8f59e8ada3a7bf5a6dd68f" title="Run the virtual machine on input x, and marginalize over execution paths to return a distribution on ...">LOTHypothesis::call</a>) on the observed input. This returns a DiscreteDistribution&lt;std::string&gt; of outputs. Note that the outputs which return errors are mapped to the second argument to call, in this case the empty string. Then, we loop over outputs and add up the likelihood of the observed output x.ouput given the program output o.first weighted by the program's probability of that output o.second. This part uses p_delete_append, which is a string edit likelihood that assigns nonzero probability of any string being corrupted to any other. It computes this by imagining that the output string was corrupted by noise that deleted from the end of the string, and then appended, where both operations take place with geometric probabilities. These probabilities are passed as template arguments since that lets us compute some key pieces of this at compile time, yielding much faster code (this is a hot part of any string-based inference model).</p>
<p>We also define a print function which allows us to say how we print out the program hypothesis. Defaultly, any <a class="el" href="class_l_o_t_hypothesis.html">LOTHypothesis</a> will just print (using the format strings like "pair(%s,%s)" above) but here we would like to also show the distribution of outputs when we print, so this prints a line with a <a class="el" href="class_l_o_t_hypothesis.html#a625f5094ee8f59e8ada3a7bf5a6dd68f" title="Run the virtual machine on input x, and marginalize over execution paths to return a distribution on ...">LOTHypothesis::call</a> (which is a <a class="el" href="class_discrete_distribution.html">DiscreteDistribution</a>) and then a .string() call on the returned value.</p>
<p>The last piece of code is the actual running: Here, we define a Fleet object, which basically manages the input/output. We tell it that we want to be able to specify the alphabet and a string for the data (comma separated strings) on the command line. We create a grammar and note that this must happend after Fleet.initialize, since creating the grammar object needs to know the alphabet. Then, we create a <a class="el" href="class_top_n.html">TopN</a> object to store the top hypotheses we have found. This is basically a sorted collection of the best hypotheses found so far. We set a few control aspects of our VirtualMachine (e.g. how many steps we should run each program for, how many outputs we will consider for each program). We convert our datastr (specified on the command line) to type MyHypothesis::data_t, and do a check on whether the data contains anything not in the alphabet.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Top.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_parallel_tempering_8h.html">ParallelTempering.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_fleet_8h.html">Fleet.h</a>&quot;</span> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_builtins_8h.html">Builtins.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_v_m_s_runtime_error_8h.html">VMSRuntimeError.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// define this so we can use it</span></div>
<div class="line">std::string alphabet = <span class="stringliteral">&quot;abcd&quot;</span>;</div>
<div class="line">  </div>
<div class="line">std::string datastr = <span class="stringliteral">&quot;a:aabb,c:ccbb&quot;</span>; <span class="comment">// input-output pairs in our observed data</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv){ </div>
<div class="line">    </div>
<div class="line">    <span class="comment">// define a Fleet object</span></div>
<div class="line">    Fleet fleet(<span class="stringliteral">&quot;A simple, one-factor formal language learner&quot;</span>);</div>
<div class="line">    fleet.add_option(<span class="stringliteral">&quot;-a,--alphabet&quot;</span>, alphabet, <span class="stringliteral">&quot;Alphabet we will use&quot;</span>);    <span class="comment">// add my own args</span></div>
<div class="line">    fleet.add_option(<span class="stringliteral">&quot;-d,--data&quot;</span>,     datastr, <span class="stringliteral">&quot;Comma separated list of input data strings&quot;</span>);   </div>
<div class="line">    fleet.initialize(argc, argv);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// top stores the top hypotheses we have found. We set the number of top to store</span></div>
<div class="line">    <span class="comment">// via the command line --top=100. Internally, that sets FleetArgs::top, which is used</span></div>
<div class="line">    <span class="comment">// as the constructor for TopN. So it only works after you call Fleet.initialize above.</span></div>
<div class="line">    <a class="code" href="class_top_n.html">TopN&lt;MyHypothesis&gt;</a> top;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// mydata stores the data for the inference model</span></div>
<div class="line">    <span class="comment">// Note that Fleet has these nice string_to functions which will parse strings in a standard</span></div>
<div class="line">    <span class="comment">// format into many of its standard data types. Here, MyHypothesis::data_t is a comma-separated</span></div>
<div class="line">    <span class="comment">// list of MyHypothesis::datum_t&#39;s, and each of those is an input:output pair using the </span></div>
<div class="line">    <span class="comment">// alphabet</span></div>
<div class="line">    <span class="keyword">auto</span> mydata = string_to&lt;MyHypothesis::data_t&gt;(datastr);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// let&#39;s just check that everything in the data is in the alphabet</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; di: mydata) {</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">char</span> c: di.output) { <span class="comment">// only checking the outputs are all in the alphabet</span></div>
<div class="line">            assert(<a class="code" href="_strings_8h.html#a9e236149ce0f5aa64d809fcca5cf1c27">contains</a>(alphabet,c));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// tell Fleet&#39;s top to print each best hypothesis it finds </span></div>
<div class="line">    <span class="comment">// (this can be set with the command line --print-top-best=1)</span></div>
<div class="line">    top.<a class="code" href="class_top_n.html#a90472852f225e5b851446e4b7ced4856">print_best</a> = <span class="keyword">true</span>;</div>
<div class="line">     </div>
<div class="line">    <span class="comment">// Create a hypothesis to start our MCMC chain on</span></div>
<div class="line">    <span class="keyword">auto</span> h0 = <a class="code" href="_random_8h.html#a3585a6278806f57b964ccd1060f3b8ee">MyHypothesis::sample</a>();</div>
<div class="line">     </div>
<div class="line">    <span class="comment">// Create an MCMC chain</span></div>
<div class="line">    <a class="code" href="class_m_c_m_c_chain.html">MCMCChain</a> c(h0, &amp;mydata, top);</div>
<div class="line">     </div>
<div class="line">    <span class="comment">// Actually run -- note this uses C++&#39;s new coroutines (like python generators)</span></div>
<div class="line">    <span class="comment">// the | print(FleetArgs::print) here will print out every FleetArgs::print steps</span></div>
<div class="line">    <span class="comment">// (which is set via --print=1000). Defaultly FleetArgs::print=0, which does not print. </span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; h : c.run(<a class="code" href="struct_control.html">Control</a>() | <a class="code" href="namespace_fleet_args.html#acf2f80bb2810cea3b3eeef0c4b0edf03">print</a>(<a class="code" href="namespace_fleet_args.html#acf2f80bb2810cea3b3eeef0c4b0edf03">FleetArgs::print</a>) ) {</div>
<div class="line">        top &lt;&lt; h; <span class="comment">// add h to top</span></div>
<div class="line">         </div>
<div class="line">        <span class="comment">// we can do other stuff with h in here if we want to. </span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// at the end, print the hypotheses we found</span></div>
<div class="line">    top.<a class="code" href="class_top_n.html#a5064ec2e4e9f1defdc3cb62d9b7ddd00">print</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>And finally, we run the actual model. We make an initial hypothesis using MyHypothesis::sample, which creates a random hypothesis from the prior, we make an <a class="el" href="class_m_c_m_c_chain.html">MCMCChain</a>, and we run it. This uses C++'s fancy coroutines to let us process the samples as a loop. The c.run function takes a <a class="el" href="struct_control.html">Control</a> object, which basically specifies the number of steps to run or amount of time to run etc. When <a class="el" href="struct_control.html">Control()</a> is called with no arguments, it gets its arguments from the command line. This means that automatically, we can give a commandline arugment like "--time=30s" and this fleet program will run for 30 seconds (times can be in days (d), hours (h), minutes (m), seconds (s) or miliseconds (q).</p>
<p>Note that there are several inference schemes, and most (including the examples in Models) use <a class="el" href="class_parallel_tempering.html">ParallelTempering</a>, which seems to work best.</p>
<p>As the chain runs, it will place hypotheses into "top" (which defaultly reads the command line argument (e.g. "--top=25") to figure out how many of the best hypotheses to store. At the end of this code, we call <a class="el" href="namespace_fleet_args.html#acf2f80bb2810cea3b3eeef0c4b0edf03">top.print()</a>, which will call the .<a class="el" href="namespace_fleet_args.html#acf2f80bb2810cea3b3eeef0c4b0edf03">print()</a> function on everything in top and show them sorted by posterior probability score (remember above we overwrote MyHypothesis::print in order to have it run the program).</p>
<p>At the end of this program, as the Fleet object is destroyed, it will print out some statistics about the total number of MCMC steps, total runtime, etc. (This can be turned off by setting <a class="el" href="namespace_fleet_args.html#acb1d87c67d763d1edf83ebe1377c948e">FleetArgs::print_header</a>=false). </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<div class="ttc" id="a_numerics_8h_html_af9434aea82baf2f6a5d9b6f9e36db08e"><div class="ttname"><a href="_numerics_8h.html#af9434aea82baf2f6a5d9b6f9e36db08e">infinity</a></div><div class="ttdeci">constexpr double infinity</div><div class="ttdef"><b>Definition:</b> Numerics.h:17</div></div>
<div class="ttc" id="a_fleet_8h_html"><div class="ttname"><a href="_fleet_8h.html">Fleet.h</a></div></div>
<div class="ttc" id="a_grammar_8h_html"><div class="ttname"><a href="_grammar_8h.html">Grammar.h</a></div><div class="ttdoc">A grammar stores all of the rules associated with any kind of nonterminal and permits us to sample as...</div></div>
<div class="ttc" id="aclass_l_o_t_hypothesis_html_a625f5094ee8f59e8ada3a7bf5a6dd68f"><div class="ttname"><a href="class_l_o_t_hypothesis.html#a625f5094ee8f59e8ada3a7bf5a6dd68f">LOTHypothesis::call</a></div><div class="ttdeci">virtual DiscreteDistribution&lt; output_t &gt; call(const input_t x, const output_t &amp;err=output_t{})</div><div class="ttdoc">Run the virtual machine on input x, and marginalize over execution paths to return a distribution on ...</div><div class="ttdef"><b>Definition:</b> LOTHypothesis.h:287</div></div>
<div class="ttc" id="a_builtins_8h_html"><div class="ttname"><a href="_builtins_8h.html">Builtins.h</a></div></div>
<div class="ttc" id="anamespace_fleet_args_html_acf2f80bb2810cea3b3eeef0c4b0edf03"><div class="ttname"><a href="namespace_fleet_args.html#acf2f80bb2810cea3b3eeef0c4b0edf03">FleetArgs::print</a></div><div class="ttdeci">unsigned long print</div><div class="ttdef"><b>Definition:</b> FleetArgs.h:33</div></div>
<div class="ttc" id="a_strings_8h_html_a9e236149ce0f5aa64d809fcca5cf1c27"><div class="ttname"><a href="_strings_8h.html#a9e236149ce0f5aa64d809fcca5cf1c27">contains</a></div><div class="ttdeci">bool contains(const std::string &amp;s, const std::string &amp;x)</div><div class="ttdef"><b>Definition:</b> Strings.h:164</div></div>
<div class="ttc" id="a_parallel_tempering_8h_html"><div class="ttname"><a href="_parallel_tempering_8h.html">ParallelTempering.h</a></div><div class="ttdoc">This is a chain pool that runs multiple chains on a ladder of different temperatures and adjusts temp...</div></div>
<div class="ttc" id="amain_8cpp_html_a3c04138a5bfe5d72780bb7e82a18e627"><div class="ttname"><a href="main_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="ttdeci">int main(int argc, char **argv)</div><div class="ttdef"><b>Definition:</b> main.cpp:3</div></div>
<div class="ttc" id="a_v_m_s_runtime_error_8h_html"><div class="ttname"><a href="_v_m_s_runtime_error_8h.html">VMSRuntimeError.h</a></div></div>
<div class="ttc" id="aclass_l_o_t_hypothesis_html"><div class="ttname"><a href="class_l_o_t_hypothesis.html">LOTHypothesis</a></div><div class="ttdef"><b>Definition:</b> LOTHypothesis.h:44</div></div>
<div class="ttc" id="a_random_8h_html_a3585a6278806f57b964ccd1060f3b8ee"><div class="ttname"><a href="_random_8h.html#a3585a6278806f57b964ccd1060f3b8ee">sample</a></div><div class="ttdeci">std::pair&lt; t *, double &gt; sample(const T &amp;s, double z, const std::function&lt; double(const t &amp;)&gt; &amp;f=[](const t &amp;v){return 1.0;})</div><div class="ttdef"><b>Definition:</b> Random.h:209</div></div>
<div class="ttc" id="a_singleton_8h_html"><div class="ttname"><a href="_singleton_8h.html">Singleton.h</a></div></div>
<div class="ttc" id="aclass_singleton_html"><div class="ttname"><a href="class_singleton.html">Singleton</a></div><div class="ttdef"><b>Definition:</b> Singleton.h:6</div></div>
<div class="ttc" id="aclass_top_n_html_a5064ec2e4e9f1defdc3cb62d9b7ddd00"><div class="ttname"><a href="class_top_n.html#a5064ec2e4e9f1defdc3cb62d9b7ddd00">TopN::print</a></div><div class="ttdeci">void print(std::string prefix=&quot;&quot;)</div><div class="ttdef"><b>Definition:</b> TopN.h:231</div></div>
<div class="ttc" id="aclass_v_m_s_runtime_error_html"><div class="ttname"><a href="class_v_m_s_runtime_error.html">VMSRuntimeError</a></div><div class="ttdef"><b>Definition:</b> VMSRuntimeError.h:13</div></div>
<div class="ttc" id="aclass_grammar_html"><div class="ttname"><a href="class_grammar.html">Grammar</a></div><div class="ttdef"><b>Definition:</b> Grammar.h:39</div></div>
<div class="ttc" id="aclass_top_n_html"><div class="ttname"><a href="class_top_n.html">TopN</a></div><div class="ttdef"><b>Definition:</b> TopN.h:25</div></div>
<div class="ttc" id="astruct_control_html"><div class="ttname"><a href="struct_control.html">Control</a></div><div class="ttdef"><b>Definition:</b> Control.h:23</div></div>
<div class="ttc" id="a_strings_8h_html_a1bb5ec0bee0c8456e3fcc87cc012d055"><div class="ttname"><a href="_strings_8h.html#a1bb5ec0bee0c8456e3fcc87cc012d055">Q</a></div><div class="ttdeci">std::string Q(std::string x)</div><div class="ttdef"><b>Definition:</b> Strings.h:354</div></div>
<div class="ttc" id="aclass_m_c_m_c_chain_html"><div class="ttname"><a href="class_m_c_m_c_chain.html">MCMCChain</a></div><div class="ttdef"><b>Definition:</b> MCMCChain.h:21</div></div>
<div class="ttc" id="aclass_l_o_t_hypothesis_html_a020bfe8e12d80add92c665518650c4cb"><div class="ttname"><a href="class_l_o_t_hypothesis.html#a020bfe8e12d80add92c665518650c4cb">LOTHypothesis::compute_single_likelihood</a></div><div class="ttdeci">virtual double compute_single_likelihood(const datum_t &amp;datum) override</div><div class="ttdef"><b>Definition:</b> LOTHypothesis.h:188</div></div>
<div class="ttc" id="aclass_grammar_html_af43a4d8c3c2c7df80a916a5219b7232c"><div class="ttname"><a href="class_grammar.html#af43a4d8c3c2c7df80a916a5219b7232c">Grammar::add_terminal</a></div><div class="ttdeci">void add_terminal(std::string fmt, T x, double p=1.0, Op o=Op::Standard, int a=0)</div><div class="ttdoc">Add a variable that is NOT A function ‚Äì simplification for adding alphabets etc. This just wraps stuf...</div><div class="ttdef"><b>Definition:</b> Grammar.h:361</div></div>
<div class="ttc" id="a_l_o_t_hypothesis_8h_html"><div class="ttname"><a href="_l_o_t_hypothesis_8h.html">LOTHypothesis.h</a></div><div class="ttdoc">A LOTHypothesis is the basic unit for doing LOT models. It store a Node as its value,...</div></div>
<div class="ttc" id="aclass_grammar_html_a07ae62095abaf00b3da2fc5065c941bf"><div class="ttname"><a href="class_grammar.html#a07ae62095abaf00b3da2fc5065c941bf">Grammar::add</a></div><div class="ttdeci">void add(std::string fmt, Builtin&lt; T, args... &gt; b, double p=1.0, int a=0)</div><div class="ttdef"><b>Definition:</b> Grammar.h:283</div></div>
<div class="ttc" id="aclass_top_n_html_a90472852f225e5b851446e4b7ced4856"><div class="ttname"><a href="class_top_n.html#a90472852f225e5b851446e4b7ced4856">TopN::print_best</a></div><div class="ttdeci">bool print_best</div><div class="ttdef"><b>Definition:</b> TopN.h:36</div></div>
<div class="ttc" id="a_numerics_8h_html_a558a1133b9942f8debd559bb9317bca3"><div class="ttname"><a href="_numerics_8h.html#a558a1133b9942f8debd559bb9317bca3">logplusexp</a></div><div class="ttdeci">T logplusexp(const T a, const T b)</div><div class="ttdef"><b>Definition:</b> Numerics.h:87</div></div>
<div class="ttc" id="aclass_bayesable_html_a87d5d9481d6a72b017e44b175071fa5e"><div class="ttname"><a href="class_bayesable.html#a87d5d9481d6a72b017e44b175071fa5e">Bayesable&lt; Args... &gt;::print</a></div><div class="ttdeci">virtual void print(std::string prefix=&quot;&quot;)</div><div class="ttdef"><b>Definition:</b> Bayesable.h:202</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
